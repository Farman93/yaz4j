<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>2. Object Identifiers</title><meta name="generator" content="DocBook XSL Stylesheets V1.73.2"><link rel="start" href="index.html" title="YAZ User's Guide and Reference"><link rel="up" href="tools.html" title="Chapter 9. Supporting Tools"><link rel="prev" href="tools.html" title="Chapter 9. Supporting Tools"><link rel="next" href="tools.nmem.html" title="3. Nibble Memory"></head><body><link rel="stylesheet" type="text/css" href="common/style1.css"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">2. Object Identifiers</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="tools.html">Prev</a> </td><th width="60%" align="center">Chapter 9. Supporting Tools</th><td width="20%" align="right"> <a accesskey="n" href="tools.nmem.html">Next</a></td></tr></table><hr></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="tools.oid"></a>2. Object Identifiers</h2></div></div></div><p>
    The basic YAZ representation of an OID is an array of integers,
    terminated with the value -1. This integer is of type 
    <code class="literal">Odr_oid</code>.
   </p><p>
    Fundamental OID operations and the type <code class="literal">Odr_oid</code>
    are defined in <code class="filename">yaz/oid_util.h</code>.
   </p><p>
    An OID can either be declared as a automatic variable or it can
    allocated using the memory utilities or ODR/NMEM. It's
    guaranteed that an OID can fit in <code class="literal">OID_SIZE</code> integers.
   </p><div class="example"><a name="tools.oid.bib1.1"></a><p class="title"><b>Example 9.13. Create OID on stack</b></p><div class="example-contents"><p>
     We can create an OID for the Bib-1 attribute set with:
     </p><pre class="screen">
      Odr_oid bib1[OID_SIZE];
      bib1[0] = 1;
      bib1[1] = 2;
      bib1[2] = 840;
      bib1[3] = 10003;
      bib1[4] = 3;
      bib1[5] = 1;
      bib1[6] = -1;
     </pre><p>
    </p></div></div><br class="example-break"><p>
    And OID may also be filled from a string-based representation using
    dots (.). This is achieved by function
    </p><pre class="screen">
     int oid_dotstring_to_oid(const char *name, Odr_oid *oid);
    </pre><p>
    This functions returns 0 if name could be converted; -1 otherwise.
   </p><div class="example"><a name="tools.oid.bib1.2"></a><p class="title"><b>Example 9.14. Using oid_oiddotstring_to_oid</b></p><div class="example-contents"><p>
     We can fill the Bib-1 attribute set OID easier with:
     </p><pre class="screen">
      Odr_oid bib1[OID_SIZE];
      oid_oiddotstring_to_oid("1.2.840.10003.3.1", bib1);
     </pre><p>
   </p></div></div><br class="example-break"><p>
    We can also allocate an OID dynamically on a ODR stream with:
   </p><pre class="screen">
    Odr_oid *odr_getoidbystr(ODR o, const char *str);
   </pre><p>
    This creates an OID from string-based representation using dots.
    This function take an <acronym class="acronym">ODR</acronym> stream as parameter. This stream is used to
    allocate memory for the data elements, which is released on a
    subsequent call to <code class="function">odr_reset()</code> on that stream.
   </p><div class="example"><a name="tools.oid.bib1.3"></a><p class="title"><b>Example 9.15. Using odr_getoidbystr</b></p><div class="example-contents"><p>
     We can create a OID for the Bib-1 attribute set with:
     </p><pre class="screen">
      Odr_oid *bib1 = odr_getoidbystr(odr, "1.2.840.10003.3.1");
     </pre><p>
    </p></div></div><br class="example-break"><p>
    The function
    </p><pre class="screen">
     char *oid_oid_to_dotstring(const Odr_oid *oid, char *oidbuf)
    </pre><p>
    does the reverse of <code class="function">oid_oiddotstring_to_oid</code>. It
    converts an OID to the string-based representation using dots.
    The supplied char buffer <code class="literal">oidbuf</code> holds the resulting
    string and must be at least <code class="literal">OID_STR_MAX</code> in size.
   </p><p>
    OIDs can be copied with <code class="function">oid_oidcpy</code> which takes
    two OID lists as arguments. Alternativly, an OID copy can be allocated
    on a ODR stream with:
    </p><pre class="screen">
     Odr_oid *odr_oiddup(ODR odr, const Odr_oid *o);
    </pre><p>
   </p><p>
    OIDs can be compared with <code class="function">oid_oidcmp</code> which returns
    zero if the two OIDs provided are identical; non-zero otherwise.
   </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="tools.oid.database"></a>2.1. OID database</h3></div></div></div><p>
     From YAZ version 3 and later, the oident system has been replaced
     by an OID database. OID database is a misnomer .. the old odient
     system was also a database.
    </p><p>
     The OID database is really just a map between named Object Identifiers
     (string) and their OID raw equivalents. Most operations either
     convert from string to OID or other way around.
    </p><p>
     Unfortunately, whenever we supply a string we must also specify the 
     <span class="emphasis"><em>OID class</em></span>. The class is necessary because some
     strings correspond to multiple OIDs. An example of such a string is
     <code class="literal">Bib-1</code> which may either be an attribute-set 
     or a diagnostic-set.
    </p><p>
     Applications using the YAZ database should include 
     <code class="filename">yaz/oid_db.h</code>.
    </p><p>
     A YAZ database handle is of type <code class="literal">yaz_oid_db_t</code>.
     Actually that's a pointer. You need not think deal with that.
     YAZ has a built-in database which can be considered "constant" for
     most purposes. 
     We can get hold that by using function <code class="function">yaz_oid_std</code>.
    </p><p>
     All functions with prefix <code class="function">yaz_string_to_oid</code>
     converts from class + string to OID. We have variants of this
     operation due to different memory allocation strategies.
    </p><p>
     All functions with prefix
     <code class="function">yaz_oid_to_string</code> converts from OID to string
     + class.
    </p><div class="example"><a name="tools.oid.bib1.4"></a><p class="title"><b>Example 9.16. Create OID with YAZ DB</b></p><div class="example-contents"><p>
      We can create an OID for the Bib-1 attribute set on the ODR stream
      odr with:
     </p><pre class="screen">
        Odr_oid *bib1 = 
         yaz_string_to_oid_odr(yaz_oid_std(), CLASS_ATTSET, "Bib-1", odr);
      </pre><p>
      This is more complex than using <code class="function">odr_getoidbystr</code>.
      You would only use <code class="function">yaz_string_to_oid_odr</code> when the
      string (here Bib-1) is supplied by a user or configuration.
     </p></div></div><br class="example-break"></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="tools.oid.std"></a>2.2. Standard OIDs</h3></div></div></div><p>
     All the object identifers in the standard OID database as returned
     by <code class="function">yaz_oid_std</code> can referenced directly in a
     program as a constant OID.
     Each constant OID is prefixed with <code class="literal">yaz_oid_</code> -
     followed by OID class (lowercase) - then by OID name (normalized and
     lowercase).
    </p><p>
     See <a class="xref" href="list-oids.html" title="Appendix A. List of Object Identifiers">Appendix A, <i>List of Object Identifiers</i></a> for list of all object identifiers
     built into YAZ.
     These are declared in <code class="filename">yaz/oid_std.h</code> but are
     included by <code class="filename">yaz/oid_db.h</code> as well.
    </p><div class="example"><a name="tools.oid.bib1.5"></a><p class="title"><b>Example 9.17. Use a built-in OID</b></p><div class="example-contents"><p>
      We can allocate our own OID filled with the constant OID for
      Bib-1 with:
      </p><pre class="screen">
        Odr_oid *bib1 = odr_oiddup(o, yaz_oid_attset_bib1);
      </pre><p>
     </p></div></div><br class="example-break"></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="tools.oid.oident"></a>2.3. OID oident</h3></div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
     The oident utility has been removed from YAZ version 3. This
     sub section only applies to YAZ version 2.
    </p></div><p>
    The OID module provides a higher-level representation of the
    family of object identifiers which describe the Z39.50 protocol and its
    related objects. The definition of the module interface is given in
    the <code class="filename">oid.h</code> file.
   </p><p>
    The interface is mainly based on the <code class="literal">oident</code> structure.
    The definition of this structure looks like this:
   </p><pre class="screen">
typedef struct oident
{
    oid_proto proto;
    oid_class oclass;
    oid_value value;
    int oidsuffix[OID_SIZE];
    char *desc;
} oident;
   </pre><p>
    The proto field takes one of the values
   </p><pre class="screen">
    PROTO_Z3950
    PROTO_GENERAL
   </pre><p>
    Use <code class="literal">PROTO_Z3950</code> for Z39.50 Object Identifers,
    <code class="literal">PROTO_GENERAL</code> for other types (such as
    those associated with ILL).
   </p><p>

    The oclass field takes one of the values
   </p><pre class="screen">
    CLASS_APPCTX
    CLASS_ABSYN
    CLASS_ATTSET
    CLASS_TRANSYN
    CLASS_DIAGSET
    CLASS_RECSYN
    CLASS_RESFORM
    CLASS_ACCFORM
    CLASS_EXTSERV
    CLASS_USERINFO
    CLASS_ELEMSPEC
    CLASS_VARSET
    CLASS_SCHEMA
    CLASS_TAGSET
    CLASS_GENERAL
   </pre><p>
    corresponding to the OID classes defined by the Z39.50 standard.

    Finally, the value field takes one of the values
   </p><pre class="screen">
    VAL_APDU
    VAL_BER
    VAL_BASIC_CTX
    VAL_BIB1
    VAL_EXP1
    VAL_EXT1
    VAL_CCL1
    VAL_GILS
    VAL_WAIS
    VAL_STAS
    VAL_DIAG1
    VAL_ISO2709
    VAL_UNIMARC
    VAL_INTERMARC
    VAL_CCF
    VAL_USMARC
    VAL_UKMARC
    VAL_NORMARC
    VAL_LIBRISMARC
    VAL_DANMARC
    VAL_FINMARC
    VAL_MAB
    VAL_CANMARC
    VAL_SBN
    VAL_PICAMARC
    VAL_AUSMARC
    VAL_IBERMARC
    VAL_EXPLAIN
    VAL_SUTRS
    VAL_OPAC
    VAL_SUMMARY
    VAL_GRS0
    VAL_GRS1
    VAL_EXTENDED
    VAL_RESOURCE1
    VAL_RESOURCE2
    VAL_PROMPT1
    VAL_DES1
    VAL_KRB1
    VAL_PRESSET
    VAL_PQUERY
    VAL_PCQUERY
    VAL_ITEMORDER
    VAL_DBUPDATE
    VAL_EXPORTSPEC
    VAL_EXPORTINV
    VAL_NONE
    VAL_SETM
    VAL_SETG
    VAL_VAR1
    VAL_ESPEC1
   </pre><p>
    again, corresponding to the specific OIDs defined by the standard.
    Refer to the
    <a class="ulink" href="http://www.loc.gov/z3950/agency/defns/oids.html" target="_top">
     Registry of Z39.50 Object Identifiers</a> for the
     whole list.
   </p><p>
    The desc field contains a brief, mnemonic name for the OID in question.
   </p><p>
    The function
   </p><pre class="screen">
    struct oident *oid_getentbyoid(int *o);
   </pre><p>
    takes as argument an OID, and returns a pointer to a static area
    containing an <code class="literal">oident</code> structure. You typically use
    this function when you receive a PDU containing an OID, and you wish
    to branch out depending on the specific OID value.
   </p><p>
    The function
   </p><pre class="screen">
    int *oid_ent_to_oid(struct oident *ent, int *dst);
   </pre><p>
    Takes as argument an <code class="literal">oident</code> structure - in which
    the <code class="literal">proto</code>, <code class="literal">oclass</code>/, and
    <code class="literal">value</code> fields are assumed to be set correctly -
    and returns a pointer to a the buffer as given by <code class="literal">dst</code>
    containing the base
    representation of the corresponding OID. The function returns
    NULL and the array dst is unchanged if a mapping couldn't place.
    The array <code class="literal">dst</code> should be at least of size
    <code class="literal">OID_SIZE</code>.
   </p><p>

    The <code class="function">oid_ent_to_oid()</code> function can be used whenever
    you need to prepare a PDU containing one or more OIDs. The separation of
    the <code class="literal">protocol</code> element from the remainder of the
    OID-description makes it simple to write applications that can
    communicate with either Z39.50 or OSI SR-based applications.
   </p><p>
    The function
   </p><pre class="screen">
    oid_value oid_getvalbyname(const char *name);
   </pre><p>
    takes as argument a mnemonic OID name, and returns the
    <code class="literal">/value</code> field of the first entry in the database that 
    contains the given name in its <code class="literal">desc</code> field.
   </p><p>
    Three utility functions are provided for translating OIDs'
    symbolic names (e.g. <code class="literal">Usmarc</code> into OID structures
    (int arrays) and strings containing the OID in dotted notation
    (e.g. <code class="literal">1.2.840.10003.9.5.1</code>).  They are:
   </p><pre class="screen">
    int *oid_name_to_oid(oid_class oclass, const char *name, int *oid);
    char *oid_to_dotstring(const int *oid, char *oidbuf);
    char *oid_name_to_dotstring(oid_class oclass, const char *name, char *oidbuf);
   </pre><p>
    <code class="literal">oid_name_to_oid()</code>
     translates the specified symbolic <code class="literal">name</code>,
     interpreted as being of class <code class="literal">oclass</code>.  (The
     class must be specified as many symbolic names exist within
     multiple classes - for example, <code class="literal">Zthes</code> is the
     symbolic name of an attribute set, a schema and a tag-set.)  The
     sequence of integers representing the OID is written into the
     area <code class="literal">oid</code> provided by the caller; it is the
     caller's responsibility to ensure that this area is large enough
     to contain the translated OID.  As a convenience, the address of
     the buffer (i.e. the value of <code class="literal">oid</code>) is
     returned.
   </p><p>
    <code class="literal">oid_to_dotstring()</code>
    Translates the int-array <code class="literal">oid</code> into a dotted
    string which is written into the area <code class="literal">oidbuf</code>
    supplied by the caller; it is the caller's responsibility to
    ensure that this area is large enough.  The address of the buffer
    is returned.
   </p><p>
    <code class="literal">oid_name_to_dotstring()</code>
    combines the previous two functions to derive a dotted string
    representing the OID specified by <code class="literal">oclass</code> and
    <code class="literal">name</code>, writing it into the buffer passed as
    <code class="literal">oidbuf</code> and returning its address.
   </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
     The OID module has been criticized - and perhaps rightly so
     - for needlessly abstracting the
     representation of OIDs. Other toolkits use a simple
     string-representation of OIDs with good results. In practice, we have
     found the interface comfortable and quick to work with, and it is a
     simple matter (for what it's worth) to create applications compatible
     with both ISO SR and Z39.50. Finally, the use of the
     <code class="literal">/oident</code> database is by no means mandatory.
     You can easily create your own system for representing OIDs, as long
     as it is compatible with the low-level integer-array representation
     of the ODR module.
    </p></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="tools.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="tools.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="tools.nmem.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 9. Supporting Tools </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 3. Nibble Memory</td></tr></table></div></body></html>
